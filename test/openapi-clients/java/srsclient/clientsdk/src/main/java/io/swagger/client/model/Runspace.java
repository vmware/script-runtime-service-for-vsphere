/*
 * Script Runtime Service for vSphere
 * # Script Runtime Service API    Script Runtime Service for vSphere (SRS) allows running PowerShell and PowerCLI scripts. SRS is a VC add-on that is deployed separately from VCSA. SRS can be accessed via REST API that allows you to create PowerShell instances and run PowerShell and PowerCLI scripts within. No Connect-VIServer is required to run PowerCLI against VC(s) SRS is registered to.    ## Authetication    SRS uses VC SSO as Identity and Authentication Server. Two types of authentication are supported. SIGN and Basic. SIGN authentication is purposed for Service-To-Service access to SRS resources. For convenience of the end-users SRS supports basic authentication passing username and password which are used to acquire SAML HoK token for SRS solution. When basic is used SRS exchanges the username and password for SAML HoK token from the SSO server. SRS uses the SAML token to Connect PowerCLI to VC services in further operations.   On successful authentication SRS returns API Key which is required to authorize further SRS API calls.
 *
 * OpenAPI spec version: 1.0-oas3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.ErrorDetails;
import io.swagger.client.model.RunspaceState;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import org.threeten.bp.OffsetDateTime;
/**
 * Runspace object allows you to create and delete isolated PowerShell instance for your script executions.  The API allows you to create, read, and delete runspaces.
 */
@Schema(description = "Runspace object allows you to create and delete isolated PowerShell instance for your script executions.  The API allows you to create, read, and delete runspaces.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-10-09T07:53:20.504Z[GMT]")
public class Runspace {
  @SerializedName("name")
  private String name = null;

  @SerializedName("id")
  private String id = null;

  @SerializedName("state")
  private RunspaceState state = null;

  @SerializedName("error_details")
  private ErrorDetails errorDetails = null;

  @SerializedName("run_vc_connection_script")
  private Boolean runVcConnectionScript = null;

  @SerializedName("vc_connection_script_id")
  private String vcConnectionScriptId = null;

  @SerializedName("creation_time")
  private OffsetDateTime creationTime = null;

  public Runspace name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the runspace. It is optional to give a name of the runspace on create request. If name was not specified on runspace creation the field has null value.
   * @return name
  **/
  @Schema(description = "Name of the runspace. It is optional to give a name of the runspace on create request. If name was not specified on runspace creation the field has null value.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

   /**
   * Unique identifier for the object.
   * @return id
  **/
  @Schema(description = "Unique identifier for the object.")
  public String getId() {
    return id;
  }

  public Runspace state(RunspaceState state) {
    this.state = state;
    return this;
  }

   /**
   * Get state
   * @return state
  **/
  @Schema(description = "")
  public RunspaceState getState() {
    return state;
  }

  public void setState(RunspaceState state) {
    this.state = state;
  }

  public Runspace errorDetails(ErrorDetails errorDetails) {
    this.errorDetails = errorDetails;
    return this;
  }

   /**
   * Get errorDetails
   * @return errorDetails
  **/
  @Schema(description = "")
  public ErrorDetails getErrorDetails() {
    return errorDetails;
  }

  public void setErrorDetails(ErrorDetails errorDetails) {
    this.errorDetails = errorDetails;
  }

  public Runspace runVcConnectionScript(Boolean runVcConnectionScript) {
    this.runVcConnectionScript = runVcConnectionScript;
    return this;
  }

   /**
   * Boolean that indicates whether PowerCLI connection has to be initialized when a Runspace creation is requested.    It is optional to request VCenter Servers connection to be initialized on create request.  If true is specified PowerCLI Connect-VIServer cmdlet will be called in the create PowerShell instance.  Connect-VIServer uses the authorized user&#x27;s SSO SAML token to connect to VCenter servers.  Connection to all linked VCetner servers will be established. When requested the runspace creation will be slower  with the time needed for PowerCLI modules loading and Connect-VIServer execution time. _vc_connection_script_state  field will hold state of the script completion. In case errors have occured during connect script execution  _vc_connection_script_error_records will be populated.    Default value is false.
   * @return runVcConnectionScript
  **/
  @Schema(description = "Boolean that indicates whether PowerCLI connection has to be initialized when a Runspace creation is requested.    It is optional to request VCenter Servers connection to be initialized on create request.  If true is specified PowerCLI Connect-VIServer cmdlet will be called in the create PowerShell instance.  Connect-VIServer uses the authorized user's SSO SAML token to connect to VCenter servers.  Connection to all linked VCetner servers will be established. When requested the runspace creation will be slower  with the time needed for PowerCLI modules loading and Connect-VIServer execution time. _vc_connection_script_state  field will hold state of the script completion. In case errors have occured during connect script execution  _vc_connection_script_error_records will be populated.    Default value is false.")
  public Boolean isRunVcConnectionScript() {
    return runVcConnectionScript;
  }

  public void setRunVcConnectionScript(Boolean runVcConnectionScript) {
    this.runVcConnectionScript = runVcConnectionScript;
  }

   /**
   * Id of vc connection script if it was requested on runspace create request.  You can use this id to retrieve all the details of the script execution.  The script could fail and the details about the script failure would be available in scriptexecutions API.
   * @return vcConnectionScriptId
  **/
  @Schema(description = "Id of vc connection script if it was requested on runspace create request.  You can use this id to retrieve all the details of the script execution.  The script could fail and the details about the script failure would be available in scriptexecutions API.")
  public String getVcConnectionScriptId() {
    return vcConnectionScriptId;
  }

   /**
   * Time at which the object was created. String representing time in format ISO 8601.
   * @return creationTime
  **/
  @Schema(description = "Time at which the object was created. String representing time in format ISO 8601.")
  public OffsetDateTime getCreationTime() {
    return creationTime;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Runspace runspace = (Runspace) o;
    return Objects.equals(this.name, runspace.name) &&
        Objects.equals(this.id, runspace.id) &&
        Objects.equals(this.state, runspace.state) &&
        Objects.equals(this.errorDetails, runspace.errorDetails) &&
        Objects.equals(this.runVcConnectionScript, runspace.runVcConnectionScript) &&
        Objects.equals(this.vcConnectionScriptId, runspace.vcConnectionScriptId) &&
        Objects.equals(this.creationTime, runspace.creationTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, id, state, errorDetails, runVcConnectionScript, vcConnectionScriptId, creationTime);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Runspace {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    errorDetails: ").append(toIndentedString(errorDetails)).append("\n");
    sb.append("    runVcConnectionScript: ").append(toIndentedString(runVcConnectionScript)).append("\n");
    sb.append("    vcConnectionScriptId: ").append(toIndentedString(vcConnectionScriptId)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
