/*
 * Script Runtime Service for vSphere
 * # Script Runtime Service API    Script Runtime Service for vSphere (SRS) allows running PowerShell and PowerCLI scripts. SRS is a VC add-on that is deployed separately from VCSA. SRS can be accessed via REST API that allows you to create PowerShell instances and run PowerShell and PowerCLI scripts within. No Connect-VIServer is required to run PowerCLI against VC(s) SRS is registered to.    ## Authetication    SRS uses VC SSO as Identity and Authentication Server. Two types of authentication are supported. SIGN and Basic. SIGN authentication is purposed for Service-To-Service access to SRS resources. For convenience of the end-users SRS supports basic authentication passing username and password which are used to acquire SAML HoK token for SRS solution. When basic is used SRS exchanges the username and password for SAML HoK token from the SSO server. SRS uses the SAML token to Connect PowerCLI to VC services in further operations.   On successful authentication SRS returns API Key which is required to authorize further SRS API calls.
 *
 * OpenAPI spec version: 1.0-oas3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * ArgumentScriptTemplate object represents a script with placeholders. If placeholders are replaced by values script can be executed.  The purpose of the script is to produce an object of type valid for a given script runtime. The result type of the script is usually  input type for other scripts. The ArgumentScriptTemplate scripts are designed to help to convert simple type values to   objects of types that can only be produced in a given script runtime.
 */
@Schema(description = "ArgumentScriptTemplate object represents a script with placeholders. If placeholders are replaced by values script can be executed.  The purpose of the script is to produce an object of type valid for a given script runtime. The result type of the script is usually  input type for other scripts. The ArgumentScriptTemplate scripts are designed to help to convert simple type values to   objects of types that can only be produced in a given script runtime.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-10-09T07:53:20.504Z[GMT]")
public class ArgumentScriptTemplate {
  @SerializedName("id")
  private String id = null;

  @SerializedName("script_runtime")
  private String scriptRuntime = null;

  @SerializedName("result_type")
  private String resultType = null;

  @SerializedName("script_template")
  private String scriptTemplate = null;

  @SerializedName("placeholders")
  private List<String> placeholders = null;

   /**
   * Unique identifier for the object.
   * @return id
  **/
  @Schema(description = "Unique identifier for the object.")
  public String getId() {
    return id;
  }

   /**
   * ScriptRuntime on which this script can be executed.
   * @return scriptRuntime
  **/
  @Schema(description = "ScriptRuntime on which this script can be executed.")
  public String getScriptRuntime() {
    return scriptRuntime;
  }

   /**
   * Type name of the object that is produced by the script template.
   * @return resultType
  **/
  @Schema(description = "Type name of the object that is produced by the script template.")
  public String getResultType() {
    return resultType;
  }

   /**
   * The script template.
   * @return scriptTemplate
  **/
  @Schema(description = "The script template.")
  public String getScriptTemplate() {
    return scriptTemplate;
  }

  public ArgumentScriptTemplate placeholders(List<String> placeholders) {
    this.placeholders = placeholders;
    return this;
  }

  public ArgumentScriptTemplate addPlaceholdersItem(String placeholdersItem) {
    if (this.placeholders == null) {
      this.placeholders = new ArrayList<String>();
    }
    this.placeholders.add(placeholdersItem);
    return this;
  }

   /**
   * The script template placeholders that has to be replaced by strings to produce a valid script.
   * @return placeholders
  **/
  @Schema(description = "The script template placeholders that has to be replaced by strings to produce a valid script.")
  public List<String> getPlaceholders() {
    return placeholders;
  }

  public void setPlaceholders(List<String> placeholders) {
    this.placeholders = placeholders;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ArgumentScriptTemplate argumentScriptTemplate = (ArgumentScriptTemplate) o;
    return Objects.equals(this.id, argumentScriptTemplate.id) &&
        Objects.equals(this.scriptRuntime, argumentScriptTemplate.scriptRuntime) &&
        Objects.equals(this.resultType, argumentScriptTemplate.resultType) &&
        Objects.equals(this.scriptTemplate, argumentScriptTemplate.scriptTemplate) &&
        Objects.equals(this.placeholders, argumentScriptTemplate.placeholders);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, scriptRuntime, resultType, scriptTemplate, placeholders);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ArgumentScriptTemplate {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    scriptRuntime: ").append(toIndentedString(scriptRuntime)).append("\n");
    sb.append("    resultType: ").append(toIndentedString(resultType)).append("\n");
    sb.append("    scriptTemplate: ").append(toIndentedString(scriptTemplate)).append("\n");
    sb.append("    placeholders: ").append(toIndentedString(placeholders)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
