/* 
 * Script Runtime Service for vSphere
 *
 * # Script Runtime Service API    Script Runtime Service for vSphere (SRS) allows running PowerShell and PowerCLI scripts. SRS is a VC add-on that is deployed separately from VCSA. SRS can be accessed via REST API that allows you to create PowerShell instances and run PowerShell and PowerCLI scripts within. No Connect-VIServer is required to run PowerCLI against VC(s) SRS is registered to.    ## Authetication    SRS uses VC SSO as Identity and Authentication Server. Two types of authentication are supported. SIGN and Basic. SIGN authentication is purposed for Service-To-Service access to SRS resources. For convenience of the end-users SRS supports basic authentication passing username and password which are used to acquire SAML HoK token for SRS solution. When basic is used SRS exchanges the username and password for SAML HoK token from the SSO server. SRS uses the SAML token to Connect PowerCLI to VC services in further operations.   On successful authentication SRS returns API Key which is required to authorize further SRS API calls.
 *
 * OpenAPI spec version: 1.0-oas3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Runspace object allows you to create and delete isolated PowerShell instance for your script executions.  The API allows you to create, read, and delete runspaces.
    /// </summary>
    [DataContract]
        public partial class Runspace :  IEquatable<Runspace>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets State
        /// </summary>
        [DataMember(Name="state", EmitDefaultValue=false)]
        public RunspaceState? State { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Runspace" /> class.
        /// </summary>
        /// <param name="name">Name of the runspace. It is optional to give a name of the runspace on create request. If name was not specified on runspace creation the field has null value..</param>
        /// <param name="state">state.</param>
        /// <param name="errorDetails">errorDetails.</param>
        /// <param name="runVcConnectionScript">Boolean that indicates whether PowerCLI connection has to be initialized when a Runspace creation is requested.    It is optional to request VCenter Servers connection to be initialized on create request.  If true is specified PowerCLI Connect-VIServer cmdlet will be called in the create PowerShell instance.  Connect-VIServer uses the authorized user&#x27;s SSO SAML token to connect to VCenter servers.  Connection to all linked VCetner servers will be established. When requested the runspace creation will be slower  with the time needed for PowerCLI modules loading and Connect-VIServer execution time. _vc_connection_script_state  field will hold state of the script completion. In case errors have occured during connect script execution  _vc_connection_script_error_records will be populated.    Default value is false..</param>
        public Runspace(string name = default(string), RunspaceState? state = default(RunspaceState?), ErrorDetails errorDetails = default(ErrorDetails), bool? runVcConnectionScript = default(bool?))
        {
            this.Name = name;
            this.State = state;
            this.ErrorDetails = errorDetails;
            this.RunVcConnectionScript = runVcConnectionScript;
        }
        
        /// <summary>
        /// Name of the runspace. It is optional to give a name of the runspace on create request. If name was not specified on runspace creation the field has null value.
        /// </summary>
        /// <value>Name of the runspace. It is optional to give a name of the runspace on create request. If name was not specified on runspace creation the field has null value.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Unique identifier for the object.
        /// </summary>
        /// <value>Unique identifier for the object.</value>
        [DataMember(Name="id", EmitDefaultValue=false)]
        public string Id { get; private set; }


        /// <summary>
        /// Gets or Sets ErrorDetails
        /// </summary>
        [DataMember(Name="error_details", EmitDefaultValue=false)]
        public ErrorDetails ErrorDetails { get; set; }

        /// <summary>
        /// Boolean that indicates whether PowerCLI connection has to be initialized when a Runspace creation is requested.    It is optional to request VCenter Servers connection to be initialized on create request.  If true is specified PowerCLI Connect-VIServer cmdlet will be called in the create PowerShell instance.  Connect-VIServer uses the authorized user&#x27;s SSO SAML token to connect to VCenter servers.  Connection to all linked VCetner servers will be established. When requested the runspace creation will be slower  with the time needed for PowerCLI modules loading and Connect-VIServer execution time. _vc_connection_script_state  field will hold state of the script completion. In case errors have occured during connect script execution  _vc_connection_script_error_records will be populated.    Default value is false.
        /// </summary>
        /// <value>Boolean that indicates whether PowerCLI connection has to be initialized when a Runspace creation is requested.    It is optional to request VCenter Servers connection to be initialized on create request.  If true is specified PowerCLI Connect-VIServer cmdlet will be called in the create PowerShell instance.  Connect-VIServer uses the authorized user&#x27;s SSO SAML token to connect to VCenter servers.  Connection to all linked VCetner servers will be established. When requested the runspace creation will be slower  with the time needed for PowerCLI modules loading and Connect-VIServer execution time. _vc_connection_script_state  field will hold state of the script completion. In case errors have occured during connect script execution  _vc_connection_script_error_records will be populated.    Default value is false.</value>
        [DataMember(Name="run_vc_connection_script", EmitDefaultValue=false)]
        public bool? RunVcConnectionScript { get; set; }

        /// <summary>
        /// Id of vc connection script if it was requested on runspace create request.  You can use this id to retrieve all the details of the script execution.  The script could fail and the details about the script failure would be available in scriptexecutions API.
        /// </summary>
        /// <value>Id of vc connection script if it was requested on runspace create request.  You can use this id to retrieve all the details of the script execution.  The script could fail and the details about the script failure would be available in scriptexecutions API.</value>
        [DataMember(Name="vc_connection_script_id", EmitDefaultValue=false)]
        public string VcConnectionScriptId { get; private set; }

        /// <summary>
        /// Time at which the object was created. String representing time in format ISO 8601.
        /// </summary>
        /// <value>Time at which the object was created. String representing time in format ISO 8601.</value>
        [DataMember(Name="creation_time", EmitDefaultValue=false)]
        public DateTime? CreationTime { get; private set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Runspace {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  ErrorDetails: ").Append(ErrorDetails).Append("\n");
            sb.Append("  RunVcConnectionScript: ").Append(RunVcConnectionScript).Append("\n");
            sb.Append("  VcConnectionScriptId: ").Append(VcConnectionScriptId).Append("\n");
            sb.Append("  CreationTime: ").Append(CreationTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Runspace);
        }

        /// <summary>
        /// Returns true if Runspace instances are equal
        /// </summary>
        /// <param name="input">Instance of Runspace to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Runspace input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.State == input.State ||
                    (this.State != null &&
                    this.State.Equals(input.State))
                ) && 
                (
                    this.ErrorDetails == input.ErrorDetails ||
                    (this.ErrorDetails != null &&
                    this.ErrorDetails.Equals(input.ErrorDetails))
                ) && 
                (
                    this.RunVcConnectionScript == input.RunVcConnectionScript ||
                    (this.RunVcConnectionScript != null &&
                    this.RunVcConnectionScript.Equals(input.RunVcConnectionScript))
                ) && 
                (
                    this.VcConnectionScriptId == input.VcConnectionScriptId ||
                    (this.VcConnectionScriptId != null &&
                    this.VcConnectionScriptId.Equals(input.VcConnectionScriptId))
                ) && 
                (
                    this.CreationTime == input.CreationTime ||
                    (this.CreationTime != null &&
                    this.CreationTime.Equals(input.CreationTime))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Id != null)
                    hashCode = hashCode * 59 + this.Id.GetHashCode();
                if (this.State != null)
                    hashCode = hashCode * 59 + this.State.GetHashCode();
                if (this.ErrorDetails != null)
                    hashCode = hashCode * 59 + this.ErrorDetails.GetHashCode();
                if (this.RunVcConnectionScript != null)
                    hashCode = hashCode * 59 + this.RunVcConnectionScript.GetHashCode();
                if (this.VcConnectionScriptId != null)
                    hashCode = hashCode * 59 + this.VcConnectionScriptId.GetHashCode();
                if (this.CreationTime != null)
                    hashCode = hashCode * 59 + this.CreationTime.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
