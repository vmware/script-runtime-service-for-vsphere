/* 
 * Script Runtime Service for vSphere
 *
 * # Script Runtime Service API    Script Runtime Service for vSphere (SRS) allows running PowerShell and PowerCLI scripts. SRS is a VC add-on that is deployed separately from VCSA. SRS can be accessed via REST API that allows you to create PowerShell instances and run PowerShell and PowerCLI scripts within. No Connect-VIServer is required to run PowerCLI against VC(s) SRS is registered to.    ## Authetication    SRS uses VC SSO as Identity and Authentication Server. Two types of authentication are supported. SIGN and Basic. SIGN authentication is purposed for Service-To-Service access to SRS resources. For convenience of the end-users SRS supports basic authentication passing username and password which are used to acquire SAML HoK token for SRS solution. When basic is used SRS exchanges the username and password for SAML HoK token from the SSO server. SRS uses the SAML token to Connect PowerCLI to VC services in further operations.   On successful authentication SRS returns API Key which is required to authorize further SRS API calls.
 *
 * OpenAPI spec version: 1.0-oas3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IScriptexecutionsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Cancels a script execution
        /// </summary>
        /// <remarks>
        /// ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns></returns>
        void CancelScriptExecution (string id);

        /// <summary>
        /// Cancels a script execution
        /// </summary>
        /// <remarks>
        /// ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CancelScriptExecutionWithHttpInfo (string id);
        /// <summary>
        /// Creates a script execution
        /// </summary>
        /// <remarks>
        /// ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>ScriptExecution</returns>
        ScriptExecution CreateScriptExecution (ScriptExecution body = null);

        /// <summary>
        /// Creates a script execution
        /// </summary>
        /// <remarks>
        /// ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>ApiResponse of ScriptExecution</returns>
        ApiResponse<ScriptExecution> CreateScriptExecutionWithHttpInfo (ScriptExecution body = null);
        /// <summary>
        /// Retrieve a script execution
        /// </summary>
        /// <remarks>
        /// ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ScriptExecution</returns>
        ScriptExecution GetScriptExecution (string id);

        /// <summary>
        /// Retrieve a script execution
        /// </summary>
        /// <remarks>
        /// ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of ScriptExecution</returns>
        ApiResponse<ScriptExecution> GetScriptExecutionWithHttpInfo (string id);
        /// <summary>
        /// Retrieves output objects produced by a script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>List&lt;string&gt;</returns>
        List<string> GetScriptExecutionOutput (string id);

        /// <summary>
        /// Retrieves output objects produced by a script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        ApiResponse<List<string>> GetScriptExecutionOutputWithHttpInfo (string id);
        /// <summary>
        /// Retrieves list of stream records received during script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>List&lt;StreamRecord&gt;</returns>
        List<StreamRecord> GetScriptExecutionStream (string id, StreamType streamType);

        /// <summary>
        /// Retrieves list of stream records received during script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>ApiResponse of List&lt;StreamRecord&gt;</returns>
        ApiResponse<List<StreamRecord>> GetScriptExecutionStreamWithHttpInfo (string id, StreamType streamType);
        /// <summary>
        /// List all script executions
        /// </summary>
        /// <remarks>
        /// ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;ScriptExecution&gt;</returns>
        List<ScriptExecution> ListScriptExecutions ();

        /// <summary>
        /// List all script executions
        /// </summary>
        /// <remarks>
        /// ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;ScriptExecution&gt;</returns>
        ApiResponse<List<ScriptExecution>> ListScriptExecutionsWithHttpInfo ();
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Cancels a script execution
        /// </summary>
        /// <remarks>
        /// ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CancelScriptExecutionAsync (string id);

        /// <summary>
        /// Cancels a script execution
        /// </summary>
        /// <remarks>
        /// ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CancelScriptExecutionAsyncWithHttpInfo (string id);
        /// <summary>
        /// Creates a script execution
        /// </summary>
        /// <remarks>
        /// ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>Task of ScriptExecution</returns>
        System.Threading.Tasks.Task<ScriptExecution> CreateScriptExecutionAsync (ScriptExecution body = null);

        /// <summary>
        /// Creates a script execution
        /// </summary>
        /// <remarks>
        /// ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>Task of ApiResponse (ScriptExecution)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScriptExecution>> CreateScriptExecutionAsyncWithHttpInfo (ScriptExecution body = null);
        /// <summary>
        /// Retrieve a script execution
        /// </summary>
        /// <remarks>
        /// ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ScriptExecution</returns>
        System.Threading.Tasks.Task<ScriptExecution> GetScriptExecutionAsync (string id);

        /// <summary>
        /// Retrieve a script execution
        /// </summary>
        /// <remarks>
        /// ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse (ScriptExecution)</returns>
        System.Threading.Tasks.Task<ApiResponse<ScriptExecution>> GetScriptExecutionAsyncWithHttpInfo (string id);
        /// <summary>
        /// Retrieves output objects produced by a script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        System.Threading.Tasks.Task<List<string>> GetScriptExecutionOutputAsync (string id);

        /// <summary>
        /// Retrieves output objects produced by a script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<string>>> GetScriptExecutionOutputAsyncWithHttpInfo (string id);
        /// <summary>
        /// Retrieves list of stream records received during script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>Task of List&lt;StreamRecord&gt;</returns>
        System.Threading.Tasks.Task<List<StreamRecord>> GetScriptExecutionStreamAsync (string id, StreamType streamType);

        /// <summary>
        /// Retrieves list of stream records received during script execution.
        /// </summary>
        /// <remarks>
        /// ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>Task of ApiResponse (List&lt;StreamRecord&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<StreamRecord>>> GetScriptExecutionStreamAsyncWithHttpInfo (string id, StreamType streamType);
        /// <summary>
        /// List all script executions
        /// </summary>
        /// <remarks>
        /// ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;ScriptExecution&gt;</returns>
        System.Threading.Tasks.Task<List<ScriptExecution>> ListScriptExecutionsAsync ();

        /// <summary>
        /// List all script executions
        /// </summary>
        /// <remarks>
        /// ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;ScriptExecution&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ScriptExecution>>> ListScriptExecutionsAsyncWithHttpInfo ();
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class ScriptexecutionsApi : IScriptexecutionsApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptexecutionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ScriptexecutionsApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptexecutionsApi"/> class
        /// </summary>
        /// <returns></returns>
        public ScriptexecutionsApi()
        {
            this.Configuration = IO.Swagger.Client.Configuration.Default;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ScriptexecutionsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ScriptexecutionsApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Cancels a script execution ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns></returns>
        public void CancelScriptExecution (string id)
        {
             CancelScriptExecutionWithHttpInfo(id);
        }

        /// <summary>
        /// Cancels a script execution ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> CancelScriptExecutionWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->CancelScriptExecution");

            var localVarPath = "/api/script-executions/{id}/cancel";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CancelScriptExecution", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Cancels a script execution ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CancelScriptExecutionAsync (string id)
        {
             await CancelScriptExecutionAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Cancels a script execution ### Cancel a script execution  This operation is equivalent of pressing Ctrl+C in the PowerShell console. If the script is cancellable it will be cancelled.  The state of the **script execution** will become cancelled after this operation. The operation is asynchronous. Cancel request  is sent to the runtime.    ### Returns  The operation doesn&#x27;t return value. **200 Ok** will be returned if the request is successful.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the script execution</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> CancelScriptExecutionAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->CancelScriptExecution");

            var localVarPath = "/api/script-executions/{id}/cancel";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CancelScriptExecution", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Creates a script execution ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>ScriptExecution</returns>
        public ScriptExecution CreateScriptExecution (ScriptExecution body = null)
        {
             ApiResponse<ScriptExecution> localVarResponse = CreateScriptExecutionWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Creates a script execution ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>ApiResponse of ScriptExecution</returns>
        public ApiResponse< ScriptExecution > CreateScriptExecutionWithHttpInfo (ScriptExecution body = null)
        {

            var localVarPath = "/api/script-executions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateScriptExecution", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ScriptExecution>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ScriptExecution) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ScriptExecution)));
        }

        /// <summary>
        /// Creates a script execution ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>Task of ScriptExecution</returns>
        public async System.Threading.Tasks.Task<ScriptExecution> CreateScriptExecutionAsync (ScriptExecution body = null)
        {
             ApiResponse<ScriptExecution> localVarResponse = await CreateScriptExecutionAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Creates a script execution ### Create a script execution  **Script execution** represents asynchronous execution of a script in a specified **runspace**  When created **script execution** starts running in the **runspace**. To monitor the script execution  progress polling of the resource by its identifier should be used.  ### Retruns  When request is accepted **202 Accepted** with **Location** header is returned in the response that leads you to the **script execution** resource that is in running state initially.  When script execution is requested with non existing runspace  **404 Not Found** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Desired script execution resource. (optional)</param>
        /// <returns>Task of ApiResponse (ScriptExecution)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ScriptExecution>> CreateScriptExecutionAsyncWithHttpInfo (ScriptExecution body = null)
        {

            var localVarPath = "/api/script-executions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateScriptExecution", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ScriptExecution>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ScriptExecution) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ScriptExecution)));
        }

        /// <summary>
        /// Retrieve a script execution ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ScriptExecution</returns>
        public ScriptExecution GetScriptExecution (string id)
        {
             ApiResponse<ScriptExecution> localVarResponse = GetScriptExecutionWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a script execution ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of ScriptExecution</returns>
        public ApiResponse< ScriptExecution > GetScriptExecutionWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->GetScriptExecution");

            var localVarPath = "/api/script-executions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetScriptExecution", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ScriptExecution>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ScriptExecution) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ScriptExecution)));
        }

        /// <summary>
        /// Retrieve a script execution ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ScriptExecution</returns>
        public async System.Threading.Tasks.Task<ScriptExecution> GetScriptExecutionAsync (string id)
        {
             ApiResponse<ScriptExecution> localVarResponse = await GetScriptExecutionAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve a script execution ### Retrieve a script execution  Retrieves the details of a **script execution**. You need only supply the unique script execution identifier that was returned on script execution creation.        ### Returns  Returns a **script execution** resource instance if a valid identifier was provided.  When requesting the Id of a script execution that doesn&#x27;t exist **404 NotFound** is returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse (ScriptExecution)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ScriptExecution>> GetScriptExecutionAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->GetScriptExecution");

            var localVarPath = "/api/script-executions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetScriptExecution", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ScriptExecution>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ScriptExecution) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ScriptExecution)));
        }

        /// <summary>
        /// Retrieves output objects produced by a script execution. ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>List&lt;string&gt;</returns>
        public List<string> GetScriptExecutionOutput (string id)
        {
             ApiResponse<List<string>> localVarResponse = GetScriptExecutionOutputWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves output objects produced by a script execution. ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        public ApiResponse< List<string> > GetScriptExecutionOutputWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->GetScriptExecutionOutput");

            var localVarPath = "/api/script-executions/{id}/output";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetScriptExecutionOutput", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<string>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<string>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<string>)));
        }

        /// <summary>
        /// Retrieves output objects produced by a script execution. ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        public async System.Threading.Tasks.Task<List<string>> GetScriptExecutionOutputAsync (string id)
        {
             ApiResponse<List<string>> localVarResponse = await GetScriptExecutionOutputAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieves output objects produced by a script execution. ### Retrieves output objects produced by a script execution ###  Output object could be in different format depending on the requested output object format on **script execution** request.  Text and json are currently supported.  When text is requested the objects that are produces ad an output by the script execution are formatted in table, the same way Format-Table formats the objects in PowerShell. Each item in the list of string represents single line of formatted output.  When output is formatted in json custom json formatting is used to serialize the objects produced by the script execution. The json object contain type name and full name of the interfaces the object implements. This is suitable if you want to present the objects in some context.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<string>>> GetScriptExecutionOutputAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->GetScriptExecutionOutput");

            var localVarPath = "/api/script-executions/{id}/output";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetScriptExecutionOutput", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<string>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<string>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<string>)));
        }

        /// <summary>
        /// Retrieves list of stream records received during script execution. ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>List&lt;StreamRecord&gt;</returns>
        public List<StreamRecord> GetScriptExecutionStream (string id, StreamType streamType)
        {
             ApiResponse<List<StreamRecord>> localVarResponse = GetScriptExecutionStreamWithHttpInfo(id, streamType);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieves list of stream records received during script execution. ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>ApiResponse of List&lt;StreamRecord&gt;</returns>
        public ApiResponse< List<StreamRecord> > GetScriptExecutionStreamWithHttpInfo (string id, StreamType streamType)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->GetScriptExecutionStream");
            // verify the required parameter 'streamType' is set
            if (streamType == null)
                throw new ApiException(400, "Missing required parameter 'streamType' when calling ScriptexecutionsApi->GetScriptExecutionStream");

            var localVarPath = "/api/script-executions/{id}/streams/{stream-type}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (streamType != null) localVarPathParams.Add("stream-type", this.Configuration.ApiClient.ParameterToString(streamType)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetScriptExecutionStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<StreamRecord>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<StreamRecord>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<StreamRecord>)));
        }

        /// <summary>
        /// Retrieves list of stream records received during script execution. ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>Task of List&lt;StreamRecord&gt;</returns>
        public async System.Threading.Tasks.Task<List<StreamRecord>> GetScriptExecutionStreamAsync (string id, StreamType streamType)
        {
             ApiResponse<List<StreamRecord>> localVarResponse = await GetScriptExecutionStreamAsyncWithHttpInfo(id, streamType);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieves list of stream records received during script execution. ### Retrieves list of stream records received during script execution  During execution of a script the script execution engine collects streams that are produced by the script execution.  There are five types of stream: information, error, warning, debug, verbose.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Unique identifier of the script execution</param>
        /// <param name="streamType">Type of the stream for which records to be rterieved</param>
        /// <returns>Task of ApiResponse (List&lt;StreamRecord&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<StreamRecord>>> GetScriptExecutionStreamAsyncWithHttpInfo (string id, StreamType streamType)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling ScriptexecutionsApi->GetScriptExecutionStream");
            // verify the required parameter 'streamType' is set
            if (streamType == null)
                throw new ApiException(400, "Missing required parameter 'streamType' when calling ScriptexecutionsApi->GetScriptExecutionStream");

            var localVarPath = "/api/script-executions/{id}/streams/{stream-type}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (streamType != null) localVarPathParams.Add("stream-type", this.Configuration.ApiClient.ParameterToString(streamType)); // path parameter
            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetScriptExecutionStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<StreamRecord>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<StreamRecord>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<StreamRecord>)));
        }

        /// <summary>
        /// List all script executions ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;ScriptExecution&gt;</returns>
        public List<ScriptExecution> ListScriptExecutions ()
        {
             ApiResponse<List<ScriptExecution>> localVarResponse = ListScriptExecutionsWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all script executions ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;ScriptExecution&gt;</returns>
        public ApiResponse< List<ScriptExecution> > ListScriptExecutionsWithHttpInfo ()
        {

            var localVarPath = "/api/script-executions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListScriptExecutions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ScriptExecution>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ScriptExecution>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ScriptExecution>)));
        }

        /// <summary>
        /// List all script executions ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of List&lt;ScriptExecution&gt;</returns>
        public async System.Threading.Tasks.Task<List<ScriptExecution>> ListScriptExecutionsAsync ()
        {
             ApiResponse<List<ScriptExecution>> localVarResponse = await ListScriptExecutionsAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all script executions ### List all script executions        ### Returns  Returns a list of your script executions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (List&lt;ScriptExecution&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ScriptExecution>>> ListScriptExecutionsAsyncWithHttpInfo ()
        {

            var localVarPath = "/api/script-executions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            // authentication (apiKeyAuth) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY")))
            {
                localVarHeaderParams["X-SRS-API-KEY"] = this.Configuration.GetApiKeyWithPrefix("X-SRS-API-KEY");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListScriptExecutions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ScriptExecution>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ScriptExecution>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<ScriptExecution>)));
        }

    }
}
