<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MultiTenantRunspaceProvider_CreateFailed" xml:space="preserve">
    <value>Create runspace for user "{0}" failed with error: {1}</value>
  </data>
  <data name="MultiTenantRunspaceProvider_GetFailed" xml:space="preserve">
    <value>Get runspace for user "{0}" failed with error: {1}</value>
  </data>
  <data name="MultiTenantRunspaceProvider_KillFailed" xml:space="preserve">
    <value>Kill runspace for user "{0}" failed with error: {1}</value>
  </data>
  <data name="MultiTenantRunspaceProvider_ListFailed" xml:space="preserve">
    <value>List runspaces for user "{0}" failed with error: {1}</value>
  </data>
  <data name="MultiTenantRunspaceProvider_UserHasNoRunspaces" xml:space="preserve">
    <value>User "{0}" doesn't have running runspaces</value>
  </data>
  <data name="MultiTenantRunspaceProvider_UserHasNoRunspaceWithId" xml:space="preserve">
    <value>User "{0}" doesn't have runspace with id "{1}"</value>
  </data>
  <data name="RunspaceNotFound" xml:space="preserve">
    <value>Runspace with id '{0}' not found</value>
  </data>
  <data name="ScriptsController_ScriptNotFound" xml:space="preserve">
    <value>Script with id '{0}' not found</value>
  </data>
  <data name="SRSAuthorizationHeader" xml:space="preserve">
    <value>X-SRS-API-KEY</value>
  </data>
  <data name="SessionsController_AuthenticationFailed" xml:space="preserve">
    <value>Saml Token is not valid</value>
  </data>
  <data name="SessionsController_AuthorizationHeaderIsNotValid" xml:space="preserve">
    <value>Authorization header is not valid or session has been expired.</value>
  </data>
  <data name="InvalidSessionException_SessionDoesntExist" xml:space="preserve">
    <value>Session '{0}' doesn't exist</value>
  </data>
  <data name="InvalidSessionException_SessionExpired" xml:space="preserve">
    <value>Session '{0}' has expired</value>
  </data>
  <data name="RunspaceController_List_NoRunspaces" xml:space="preserve">
    <value>There are no runspaces</value>
  </data>
  <data name="ApiVersion" xml:space="preserve">
    <value>1.0.0</value>
  </data>
  <data name="ProductName" xml:space="preserve">
    <value>Script Runtime Service for vSphere</value>
  </data>
  <data name="Vendor" xml:space="preserve">
    <value>VMware, Inc.</value>
  </data>
  <data name="PollingScriptExecutionPersister_ScriptFailed_RunspaceDisappeared" xml:space="preserve">
    <value>Runspace where script runs doesn't respond. Could be because script active time is longer than maximum allowed time for a script execution</value>
  </data>
  <data name="RunspaceController_Post_MaxnumberOfRunspacesReached" xml:space="preserve">
    <value>Maximum number of running runspaces is reached</value>
  </data>
  <data name="ScriptsController_RunspaceFailedToCancelScriptExecution" xml:space="preserve">
    <value>Runspace failed to cancel the script execution</value>
  </data>
  <data name="ScriptsController_RunspaceFailedToProcessScriptRequest" xml:space="preserve">
    <value>Runspace failed to process the script execution request</value>
  </data>
  <data name="ScriptOutputController_ScriptStorageService_FailedToRetrieveScriptOutput" xml:space="preserve">
    <value>Script Storage Service failed to retrieve script execution output</value>
  </data>
  <data name="ScriptsController_ScriptStorageService_FailedToRetrieveScripts" xml:space="preserve">
    <value>Script Storage Service failed to retrieve script execution history</value>
  </data>
  <data name="ScriptStreamsController_ScriptStorageService_FailedToRetrieveScriptStreams" xml:space="preserve">
    <value>Script Storage Service failed to retrieve script execution streams</value>
  </data>
  <data name="SessionsController_SessionsService_FailedToDeleteSession" xml:space="preserve">
    <value>Sessions Service failed to delete session</value>
  </data>
  <data name="ArgumentScriptsController_ArgumentTransformationScriptNotFound" xml:space="preserve">
    <value>Argument transformation script not found for '{0}'</value>
  </data>
  <data name="RunspaceController_Kill_RunspaceProviderKillFailed" xml:space="preserve">
    <value>Runspace Provider failed to destroy runspace with id '{0}'</value>
  </data>
  <data name="RunspaceController_List_RunspaceProviderListFailed" xml:space="preserve">
    <value>Runspace Provider failed to list user runspaces</value>
  </data>
  <data name="PowerCLIVCLoginController_Post_AcquireAuthorizationTokenFailed" xml:space="preserve">
    <value>Acquire Authorization Token from STS failed.</value>
  </data>
  <data name="PowerCLIVCloginController_NoRefreshTokenAvailable_For_Session" xml:space="preserve">
    <value>No VC refresh token is available for connect PowerCLI operation</value>
  </data>
  <data name="ProductAPIVersion" xml:space="preserve">
    <value>v1</value>
  </data>
  <data name="ProductApiDescription" xml:space="preserve">
    <value>Script Runtime Service for vSphere (SRS) enables vSphere users and services (clients) to manage PowerCLI instances and run PowerCLI scripts. SRS clients authenticate once with vSphere credentials or access token. SRS clients can create PowerCLI instances and run scripts within. PowerCLI runs server-side and automatically connects to target vCenter servers. SRS tracks history of script outputs.</value>
  </data>
  <data name="ProductVersion" xml:space="preserve">
    <value>1.0</value>
  </data>
  <data name="RunspaceNotReady" xml:space="preserve">
    <value>Runspace '{0}' is not ready to run script. Runspace state is: {1}</value>
  </data>
  <data name="AboutTagDescription" xml:space="preserve">
    <value>About information for the product</value>
  </data>
  <data name="ArgumentScriptsTagDescription" xml:space="preserve">
    <value>SRS has a number of script templates to help users pass PowerCLI objects as arguments to scripts with PowerCLI type parameters. Argument transformation scripts are scripts given on the Parameter structure that produce value which is used as an argument to specific parameter of a requested script execution.</value>
  </data>
  <data name="AuthenticationTagDescription" xml:space="preserve">
    <value>SRS uses vCenter Server SSO it is registered to as Identity and Authentication Server. SRS does not apply any role-based access control to its features. Any vSphere user that can authenticate in vCenter Server SSO can access the SRS feature. SRS establishes PowerCLI connections to vCenter Servers on behalf of the authenticated user. PowerCLI scripts run on behalf of the authenticated user.</value>
  </data>
  <data name="RunspaceTagDescription" xml:space="preserve">
    <value>Runspace is a PowerShell instance running in a dedicated container as a Kubernetes pod on the Kubernetes cluster. Runspace hosts the script running engine. Runspaces run in containers to isolate different users scripts and to isolate the script runtime from the hosting infrastructure. Multiple users can access SRS and run scripts. Different users are isolated in their own PowerShell runtime without access to other users script runtime and the underlying infrastructure. A user can create more than one runspace. So single user can run scripts simultaneously in isolated runspace. User can use one runspace to run multiple scripts sequentially.&lt;br/&gt; &lt;br/&gt; SRS presents Runspace as an API Resource with unique Id, name optionally given by the user, and state. The state of a Runspace switches during the Runspace life cycle. When Runspace creation is requested, a Runspace resource is returned in creating state. Once a runspace is prepared for running its state is switch to ready. A Runspace is in active state when it is busy running a script. Active runpsaces do not accept script execution requests.</value>
  </data>
  <data name="ScriptExecutionsTagDescription" xml:space="preserve">
    <value>To run a script in SRS, users request Script Execution. Script Execution is an SRS resource that represents a script that user requests to run in a Runspace. SRS assigns unique Id for a script execution and lets the user track the script progress and outcomes. When a script execution completes, SRS keeps a script execution record with the produced outputs. Script outputs consist of objects that script returns and messages that are raised in PowerShell run-time streams. PowerShell has six output streams Output, Error, Warning, Information, Debug, and Verbose. Everything produced by command return or Write-Output is recorded in the Output stream.</value>
  </data>
</root>